//C++ Abstract Syntax Implementation generated by the BNF Converter.
#include <algorithm>
#include <string>
#include <vector>
#include "Absyn.H"

/********************   PDefs    ********************/
PDefs::PDefs(ListDef *p1)
{
  listdef_ = p1;

}

PDefs::PDefs(const PDefs & other)
{
  listdef_ = other.listdef_->clone();

}

PDefs &PDefs::operator=(const PDefs & other)
{
  PDefs tmp(other);
  swap(tmp);
  return *this;
}

void PDefs::swap(PDefs & other)
{
  std::swap(listdef_, other.listdef_);

}

PDefs::~PDefs()
{
  delete(listdef_);

}

void PDefs::accept(Visitor *v)
{
  v->visitPDefs(this);
}

PDefs *PDefs::clone() const
{
  return new PDefs(*this);
}



/********************   DFun    ********************/
DFun::DFun(Type *p1, Id p2, ListArg *p3, ListStm *p4)
{
  type_ = p1;
  id_ = p2;
  listarg_ = p3;
  liststm_ = p4;

}

DFun::DFun(const DFun & other)
{
  type_ = other.type_->clone();
  id_ = other.id_;
  listarg_ = other.listarg_->clone();
  liststm_ = other.liststm_->clone();

}

DFun &DFun::operator=(const DFun & other)
{
  DFun tmp(other);
  swap(tmp);
  return *this;
}

void DFun::swap(DFun & other)
{
  std::swap(type_, other.type_);
  std::swap(id_, other.id_);
  std::swap(listarg_, other.listarg_);
  std::swap(liststm_, other.liststm_);

}

DFun::~DFun()
{
  delete(type_);
  delete(listarg_);
  delete(liststm_);

}

void DFun::accept(Visitor *v)
{
  v->visitDFun(this);
}

DFun *DFun::clone() const
{
  return new DFun(*this);
}



/********************   DUse    ********************/
DUse::DUse(Id p1, Id p2)
{
  id_1 = p1;
  id_2 = p2;

}

DUse::DUse(const DUse & other)
{
  id_1 = other.id_1;
  id_2 = other.id_2;

}

DUse &DUse::operator=(const DUse & other)
{
  DUse tmp(other);
  swap(tmp);
  return *this;
}

void DUse::swap(DUse & other)
{
  std::swap(id_1, other.id_1);
  std::swap(id_2, other.id_2);

}

DUse::~DUse()
{

}

void DUse::accept(Visitor *v)
{
  v->visitDUse(this);
}

DUse *DUse::clone() const
{
  return new DUse(*this);
}



/********************   DUsing2    ********************/
DUsing2::DUsing2(Id p1, Type *p2)
{
  id_ = p1;
  type_ = p2;

}

DUsing2::DUsing2(const DUsing2 & other)
{
  id_ = other.id_;
  type_ = other.type_->clone();

}

DUsing2 &DUsing2::operator=(const DUsing2 & other)
{
  DUsing2 tmp(other);
  swap(tmp);
  return *this;
}

void DUsing2::swap(DUsing2 & other)
{
  std::swap(id_, other.id_);
  std::swap(type_, other.type_);

}

DUsing2::~DUsing2()
{
  delete(type_);

}

void DUsing2::accept(Visitor *v)
{
  v->visitDUsing2(this);
}

DUsing2 *DUsing2::clone() const
{
  return new DUsing2(*this);
}



/********************   DTypDef    ********************/
DTypDef::DTypDef(Type *p1, Id p2)
{
  type_ = p1;
  id_ = p2;

}

DTypDef::DTypDef(const DTypDef & other)
{
  type_ = other.type_->clone();
  id_ = other.id_;

}

DTypDef &DTypDef::operator=(const DTypDef & other)
{
  DTypDef tmp(other);
  swap(tmp);
  return *this;
}

void DTypDef::swap(DTypDef & other)
{
  std::swap(type_, other.type_);
  std::swap(id_, other.id_);

}

DTypDef::~DTypDef()
{
  delete(type_);

}

void DTypDef::accept(Visitor *v)
{
  v->visitDTypDef(this);
}

DTypDef *DTypDef::clone() const
{
  return new DTypDef(*this);
}



/********************   DDecl    ********************/
DDecl::DDecl(Type *p1, Id p2, ListArg *p3)
{
  type_ = p1;
  id_ = p2;
  listarg_ = p3;

}

DDecl::DDecl(const DDecl & other)
{
  type_ = other.type_->clone();
  id_ = other.id_;
  listarg_ = other.listarg_->clone();

}

DDecl &DDecl::operator=(const DDecl & other)
{
  DDecl tmp(other);
  swap(tmp);
  return *this;
}

void DDecl::swap(DDecl & other)
{
  std::swap(type_, other.type_);
  std::swap(id_, other.id_);
  std::swap(listarg_, other.listarg_);

}

DDecl::~DDecl()
{
  delete(type_);
  delete(listarg_);

}

void DDecl::accept(Visitor *v)
{
  v->visitDDecl(this);
}

DDecl *DDecl::clone() const
{
  return new DDecl(*this);
}



/********************   AFunc    ********************/
AFunc::AFunc(Type *p1)
{
  type_ = p1;

}

AFunc::AFunc(const AFunc & other)
{
  type_ = other.type_->clone();

}

AFunc &AFunc::operator=(const AFunc & other)
{
  AFunc tmp(other);
  swap(tmp);
  return *this;
}

void AFunc::swap(AFunc & other)
{
  std::swap(type_, other.type_);

}

AFunc::~AFunc()
{
  delete(type_);

}

void AFunc::accept(Visitor *v)
{
  v->visitAFunc(this);
}

AFunc *AFunc::clone() const
{
  return new AFunc(*this);
}



/********************   ADecl    ********************/
ADecl::ADecl(Type *p1, Id p2)
{
  type_ = p1;
  id_ = p2;

}

ADecl::ADecl(const ADecl & other)
{
  type_ = other.type_->clone();
  id_ = other.id_;

}

ADecl &ADecl::operator=(const ADecl & other)
{
  ADecl tmp(other);
  swap(tmp);
  return *this;
}

void ADecl::swap(ADecl & other)
{
  std::swap(type_, other.type_);
  std::swap(id_, other.id_);

}

ADecl::~ADecl()
{
  delete(type_);

}

void ADecl::accept(Visitor *v)
{
  v->visitADecl(this);
}

ADecl *ADecl::clone() const
{
  return new ADecl(*this);
}



/********************   SExp    ********************/
SExp::SExp(Exp *p1)
{
  exp_ = p1;

}

SExp::SExp(const SExp & other)
{
  exp_ = other.exp_->clone();

}

SExp &SExp::operator=(const SExp & other)
{
  SExp tmp(other);
  swap(tmp);
  return *this;
}

void SExp::swap(SExp & other)
{
  std::swap(exp_, other.exp_);

}

SExp::~SExp()
{
  delete(exp_);

}

void SExp::accept(Visitor *v)
{
  v->visitSExp(this);
}

SExp *SExp::clone() const
{
  return new SExp(*this);
}



/********************   STypDef    ********************/
STypDef::STypDef(Type *p1, Id p2)
{
  type_ = p1;
  id_ = p2;

}

STypDef::STypDef(const STypDef & other)
{
  type_ = other.type_->clone();
  id_ = other.id_;

}

STypDef &STypDef::operator=(const STypDef & other)
{
  STypDef tmp(other);
  swap(tmp);
  return *this;
}

void STypDef::swap(STypDef & other)
{
  std::swap(type_, other.type_);
  std::swap(id_, other.id_);

}

STypDef::~STypDef()
{
  delete(type_);

}

void STypDef::accept(Visitor *v)
{
  v->visitSTypDef(this);
}

STypDef *STypDef::clone() const
{
  return new STypDef(*this);
}



/********************   SWhile    ********************/
SWhile::SWhile(Exp *p1, Stm *p2)
{
  exp_ = p1;
  stm_ = p2;

}

SWhile::SWhile(const SWhile & other)
{
  exp_ = other.exp_->clone();
  stm_ = other.stm_->clone();

}

SWhile &SWhile::operator=(const SWhile & other)
{
  SWhile tmp(other);
  swap(tmp);
  return *this;
}

void SWhile::swap(SWhile & other)
{
  std::swap(exp_, other.exp_);
  std::swap(stm_, other.stm_);

}

SWhile::~SWhile()
{
  delete(exp_);
  delete(stm_);

}

void SWhile::accept(Visitor *v)
{
  v->visitSWhile(this);
}

SWhile *SWhile::clone() const
{
  return new SWhile(*this);
}



/********************   SBlock    ********************/
SBlock::SBlock(ListStm *p1)
{
  liststm_ = p1;

}

SBlock::SBlock(const SBlock & other)
{
  liststm_ = other.liststm_->clone();

}

SBlock &SBlock::operator=(const SBlock & other)
{
  SBlock tmp(other);
  swap(tmp);
  return *this;
}

void SBlock::swap(SBlock & other)
{
  std::swap(liststm_, other.liststm_);

}

SBlock::~SBlock()
{
  delete(liststm_);

}

void SBlock::accept(Visitor *v)
{
  v->visitSBlock(this);
}

SBlock *SBlock::clone() const
{
  return new SBlock(*this);
}



/********************   SIf    ********************/
SIf::SIf(Exp *p1, Stm *p2)
{
  exp_ = p1;
  stm_ = p2;

}

SIf::SIf(const SIf & other)
{
  exp_ = other.exp_->clone();
  stm_ = other.stm_->clone();

}

SIf &SIf::operator=(const SIf & other)
{
  SIf tmp(other);
  swap(tmp);
  return *this;
}

void SIf::swap(SIf & other)
{
  std::swap(exp_, other.exp_);
  std::swap(stm_, other.stm_);

}

SIf::~SIf()
{
  delete(exp_);
  delete(stm_);

}

void SIf::accept(Visitor *v)
{
  v->visitSIf(this);
}

SIf *SIf::clone() const
{
  return new SIf(*this);
}



/********************   SIfElse    ********************/
SIfElse::SIfElse(Exp *p1, Stm *p2, Stm *p3)
{
  exp_ = p1;
  stm_1 = p2;
  stm_2 = p3;

}

SIfElse::SIfElse(const SIfElse & other)
{
  exp_ = other.exp_->clone();
  stm_1 = other.stm_1->clone();
  stm_2 = other.stm_2->clone();

}

SIfElse &SIfElse::operator=(const SIfElse & other)
{
  SIfElse tmp(other);
  swap(tmp);
  return *this;
}

void SIfElse::swap(SIfElse & other)
{
  std::swap(exp_, other.exp_);
  std::swap(stm_1, other.stm_1);
  std::swap(stm_2, other.stm_2);

}

SIfElse::~SIfElse()
{
  delete(exp_);
  delete(stm_1);
  delete(stm_2);

}

void SIfElse::accept(Visitor *v)
{
  v->visitSIfElse(this);
}

SIfElse *SIfElse::clone() const
{
  return new SIfElse(*this);
}



/********************   SFor    ********************/
SFor::SFor(ListExp *p1, Stm *p2)
{
  listexp_ = p1;
  stm_ = p2;

}

SFor::SFor(const SFor & other)
{
  listexp_ = other.listexp_->clone();
  stm_ = other.stm_->clone();

}

SFor &SFor::operator=(const SFor & other)
{
  SFor tmp(other);
  swap(tmp);
  return *this;
}

void SFor::swap(SFor & other)
{
  std::swap(listexp_, other.listexp_);
  std::swap(stm_, other.stm_);

}

SFor::~SFor()
{
  delete(listexp_);
  delete(stm_);

}

void SFor::accept(Visitor *v)
{
  v->visitSFor(this);
}

SFor *SFor::clone() const
{
  return new SFor(*this);
}



/********************   SReturn    ********************/
SReturn::SReturn(Exp *p1)
{
  exp_ = p1;

}

SReturn::SReturn(const SReturn & other)
{
  exp_ = other.exp_->clone();

}

SReturn &SReturn::operator=(const SReturn & other)
{
  SReturn tmp(other);
  swap(tmp);
  return *this;
}

void SReturn::swap(SReturn & other)
{
  std::swap(exp_, other.exp_);

}

SReturn::~SReturn()
{
  delete(exp_);

}

void SReturn::accept(Visitor *v)
{
  v->visitSReturn(this);
}

SReturn *SReturn::clone() const
{
  return new SReturn(*this);
}



/********************   SDoWhile    ********************/
SDoWhile::SDoWhile(Stm *p1, Exp *p2)
{
  stm_ = p1;
  exp_ = p2;

}

SDoWhile::SDoWhile(const SDoWhile & other)
{
  stm_ = other.stm_->clone();
  exp_ = other.exp_->clone();

}

SDoWhile &SDoWhile::operator=(const SDoWhile & other)
{
  SDoWhile tmp(other);
  swap(tmp);
  return *this;
}

void SDoWhile::swap(SDoWhile & other)
{
  std::swap(stm_, other.stm_);
  std::swap(exp_, other.exp_);

}

SDoWhile::~SDoWhile()
{
  delete(stm_);
  delete(exp_);

}

void SDoWhile::accept(Visitor *v)
{
  v->visitSDoWhile(this);
}

SDoWhile *SDoWhile::clone() const
{
  return new SDoWhile(*this);
}



/********************   QualConst    ********************/
QualConst::QualConst(Name *p1)
{
  name_ = p1;

}

QualConst::QualConst(const QualConst & other)
{
  name_ = other.name_->clone();

}

QualConst &QualConst::operator=(const QualConst & other)
{
  QualConst tmp(other);
  swap(tmp);
  return *this;
}

void QualConst::swap(QualConst & other)
{
  std::swap(name_, other.name_);

}

QualConst::~QualConst()
{
  delete(name_);

}

void QualConst::accept(Visitor *v)
{
  v->visitQualConst(this);
}

QualConst *QualConst::clone() const
{
  return new QualConst(*this);
}



/********************   QualConst2    ********************/
QualConst2::QualConst2(Name *p1, QC *p2)
{
  name_ = p1;
  qc_ = p2;

}

QualConst2::QualConst2(const QualConst2 & other)
{
  name_ = other.name_->clone();
  qc_ = other.qc_->clone();

}

QualConst2 &QualConst2::operator=(const QualConst2 & other)
{
  QualConst2 tmp(other);
  swap(tmp);
  return *this;
}

void QualConst2::swap(QualConst2 & other)
{
  std::swap(name_, other.name_);
  std::swap(qc_, other.qc_);

}

QualConst2::~QualConst2()
{
  delete(name_);
  delete(qc_);

}

void QualConst2::accept(Visitor *v)
{
  v->visitQualConst2(this);
}

QualConst2 *QualConst2::clone() const
{
  return new QualConst2(*this);
}



/********************   Name1    ********************/
Name1::Name1(Id p1)
{
  id_ = p1;

}

Name1::Name1(const Name1 & other)
{
  id_ = other.id_;

}

Name1 &Name1::operator=(const Name1 & other)
{
  Name1 tmp(other);
  swap(tmp);
  return *this;
}

void Name1::swap(Name1 & other)
{
  std::swap(id_, other.id_);

}

Name1::~Name1()
{

}

void Name1::accept(Visitor *v)
{
  v->visitName1(this);
}

Name1 *Name1::clone() const
{
  return new Name1(*this);
}



/********************   Name2    ********************/
Name2::Name2(Tmp *p1)
{
  tmp_ = p1;

}

Name2::Name2(const Name2 & other)
{
  tmp_ = other.tmp_->clone();

}

Name2 &Name2::operator=(const Name2 & other)
{
  Name2 tmp(other);
  swap(tmp);
  return *this;
}

void Name2::swap(Name2 & other)
{
  std::swap(tmp_, other.tmp_);

}

Name2::~Name2()
{
  delete(tmp_);

}

void Name2::accept(Visitor *v)
{
  v->visitName2(this);
}

Name2 *Name2::clone() const
{
  return new Name2(*this);
}



/********************   Template    ********************/
Template::Template(Type *p1, ListType *p2)
{
  type_ = p1;
  listtype_ = p2;

}

Template::Template(const Template & other)
{
  type_ = other.type_->clone();
  listtype_ = other.listtype_->clone();

}

Template &Template::operator=(const Template & other)
{
  Template tmp(other);
  swap(tmp);
  return *this;
}

void Template::swap(Template & other)
{
  std::swap(type_, other.type_);
  std::swap(listtype_, other.listtype_);

}

Template::~Template()
{
  delete(type_);
  delete(listtype_);

}

void Template::accept(Visitor *v)
{
  v->visitTemplate(this);
}

Template *Template::clone() const
{
  return new Template(*this);
}



/********************   TQC    ********************/
TQC::TQC(QC *p1)
{
  qc_ = p1;

}

TQC::TQC(const TQC & other)
{
  qc_ = other.qc_->clone();

}

TQC &TQC::operator=(const TQC & other)
{
  TQC tmp(other);
  swap(tmp);
  return *this;
}

void TQC::swap(TQC & other)
{
  std::swap(qc_, other.qc_);

}

TQC::~TQC()
{
  delete(qc_);

}

void TQC::accept(Visitor *v)
{
  v->visitTQC(this);
}

TQC *TQC::clone() const
{
  return new TQC(*this);
}



/********************   TAddress    ********************/
TAddress::TAddress(Type *p1)
{
  type_ = p1;

}

TAddress::TAddress(const TAddress & other)
{
  type_ = other.type_->clone();

}

TAddress &TAddress::operator=(const TAddress & other)
{
  TAddress tmp(other);
  swap(tmp);
  return *this;
}

void TAddress::swap(TAddress & other)
{
  std::swap(type_, other.type_);

}

TAddress::~TAddress()
{
  delete(type_);

}

void TAddress::accept(Visitor *v)
{
  v->visitTAddress(this);
}

TAddress *TAddress::clone() const
{
  return new TAddress(*this);
}



/********************   TConst    ********************/
TConst::TConst(Type *p1)
{
  type_ = p1;

}

TConst::TConst(const TConst & other)
{
  type_ = other.type_->clone();

}

TConst &TConst::operator=(const TConst & other)
{
  TConst tmp(other);
  swap(tmp);
  return *this;
}

void TConst::swap(TConst & other)
{
  std::swap(type_, other.type_);

}

TConst::~TConst()
{
  delete(type_);

}

void TConst::accept(Visitor *v)
{
  v->visitTConst(this);
}

TConst *TConst::clone() const
{
  return new TConst(*this);
}



/********************   Type_bool    ********************/
Type_bool::Type_bool()
{

}

Type_bool::Type_bool(const Type_bool & other)
{

}

Type_bool &Type_bool::operator=(const Type_bool & other)
{
  Type_bool tmp(other);
  swap(tmp);
  return *this;
}

void Type_bool::swap(Type_bool & other)
{

}

Type_bool::~Type_bool()
{

}

void Type_bool::accept(Visitor *v)
{
  v->visitType_bool(this);
}

Type_bool *Type_bool::clone() const
{
  return new Type_bool(*this);
}



/********************   Type_int    ********************/
Type_int::Type_int()
{

}

Type_int::Type_int(const Type_int & other)
{

}

Type_int &Type_int::operator=(const Type_int & other)
{
  Type_int tmp(other);
  swap(tmp);
  return *this;
}

void Type_int::swap(Type_int & other)
{

}

Type_int::~Type_int()
{

}

void Type_int::accept(Visitor *v)
{
  v->visitType_int(this);
}

Type_int *Type_int::clone() const
{
  return new Type_int(*this);
}



/********************   Type_double    ********************/
Type_double::Type_double()
{

}

Type_double::Type_double(const Type_double & other)
{

}

Type_double &Type_double::operator=(const Type_double & other)
{
  Type_double tmp(other);
  swap(tmp);
  return *this;
}

void Type_double::swap(Type_double & other)
{

}

Type_double::~Type_double()
{

}

void Type_double::accept(Visitor *v)
{
  v->visitType_double(this);
}

Type_double *Type_double::clone() const
{
  return new Type_double(*this);
}



/********************   Type_void    ********************/
Type_void::Type_void()
{

}

Type_void::Type_void(const Type_void & other)
{

}

Type_void &Type_void::operator=(const Type_void & other)
{
  Type_void tmp(other);
  swap(tmp);
  return *this;
}

void Type_void::swap(Type_void & other)
{

}

Type_void::~Type_void()
{

}

void Type_void::accept(Visitor *v)
{
  v->visitType_void(this);
}

Type_void *Type_void::clone() const
{
  return new Type_void(*this);
}



/********************   Type_string    ********************/
Type_string::Type_string()
{

}

Type_string::Type_string(const Type_string & other)
{

}

Type_string &Type_string::operator=(const Type_string & other)
{
  Type_string tmp(other);
  swap(tmp);
  return *this;
}

void Type_string::swap(Type_string & other)
{

}

Type_string::~Type_string()
{

}

void Type_string::accept(Visitor *v)
{
  v->visitType_string(this);
}

Type_string *Type_string::clone() const
{
  return new Type_string(*this);
}



/********************   Type_vector    ********************/
Type_vector::Type_vector()
{

}

Type_vector::Type_vector(const Type_vector & other)
{

}

Type_vector &Type_vector::operator=(const Type_vector & other)
{
  Type_vector tmp(other);
  swap(tmp);
  return *this;
}

void Type_vector::swap(Type_vector & other)
{

}

Type_vector::~Type_vector()
{

}

void Type_vector::accept(Visitor *v)
{
  v->visitType_vector(this);
}

Type_vector *Type_vector::clone() const
{
  return new Type_vector(*this);
}



/********************   Type_map    ********************/
Type_map::Type_map()
{

}

Type_map::Type_map(const Type_map & other)
{

}

Type_map &Type_map::operator=(const Type_map & other)
{
  Type_map tmp(other);
  swap(tmp);
  return *this;
}

void Type_map::swap(Type_map & other)
{

}

Type_map::~Type_map()
{

}

void Type_map::accept(Visitor *v)
{
  v->visitType_map(this);
}

Type_map *Type_map::clone() const
{
  return new Type_map(*this);
}



/********************   EType    ********************/
EType::EType(Type *p1, ListId *p2)
{
  type_ = p1;
  listid_ = p2;

}

EType::EType(const EType & other)
{
  type_ = other.type_->clone();
  listid_ = other.listid_->clone();

}

EType &EType::operator=(const EType & other)
{
  EType tmp(other);
  swap(tmp);
  return *this;
}

void EType::swap(EType & other)
{
  std::swap(type_, other.type_);
  std::swap(listid_, other.listid_);

}

EType::~EType()
{
  delete(type_);
  delete(listid_);

}

void EType::accept(Visitor *v)
{
  v->visitEType(this);
}

EType *EType::clone() const
{
  return new EType(*this);
}



/********************   EString    ********************/
EString::EString(String p1)
{
  string_ = p1;

}

EString::EString(const EString & other)
{
  string_ = other.string_;

}

EString &EString::operator=(const EString & other)
{
  EString tmp(other);
  swap(tmp);
  return *this;
}

void EString::swap(EString & other)
{
  std::swap(string_, other.string_);

}

EString::~EString()
{

}

void EString::accept(Visitor *v)
{
  v->visitEString(this);
}

EString *EString::clone() const
{
  return new EString(*this);
}



/********************   EInt    ********************/
EInt::EInt(Integer p1)
{
  integer_ = p1;

}

EInt::EInt(const EInt & other)
{
  integer_ = other.integer_;

}

EInt &EInt::operator=(const EInt & other)
{
  EInt tmp(other);
  swap(tmp);
  return *this;
}

void EInt::swap(EInt & other)
{
  std::swap(integer_, other.integer_);

}

EInt::~EInt()
{

}

void EInt::accept(Visitor *v)
{
  v->visitEInt(this);
}

EInt *EInt::clone() const
{
  return new EInt(*this);
}



/********************   EId    ********************/
EId::EId(Id p1)
{
  id_ = p1;

}

EId::EId(const EId & other)
{
  id_ = other.id_;

}

EId &EId::operator=(const EId & other)
{
  EId tmp(other);
  swap(tmp);
  return *this;
}

void EId::swap(EId & other)
{
  std::swap(id_, other.id_);

}

EId::~EId()
{

}

void EId::accept(Visitor *v)
{
  v->visitEId(this);
}

EId *EId::clone() const
{
  return new EId(*this);
}



/********************   EChar    ********************/
EChar::EChar(Char p1)
{
  char_ = p1;

}

EChar::EChar(const EChar & other)
{
  char_ = other.char_;

}

EChar &EChar::operator=(const EChar & other)
{
  EChar tmp(other);
  swap(tmp);
  return *this;
}

void EChar::swap(EChar & other)
{
  std::swap(char_, other.char_);

}

EChar::~EChar()
{

}

void EChar::accept(Visitor *v)
{
  v->visitEChar(this);
}

EChar *EChar::clone() const
{
  return new EChar(*this);
}



/********************   QTypeExp    ********************/
QTypeExp::QTypeExp(QC *p1)
{
  qc_ = p1;

}

QTypeExp::QTypeExp(const QTypeExp & other)
{
  qc_ = other.qc_->clone();

}

QTypeExp &QTypeExp::operator=(const QTypeExp & other)
{
  QTypeExp tmp(other);
  swap(tmp);
  return *this;
}

void QTypeExp::swap(QTypeExp & other)
{
  std::swap(qc_, other.qc_);

}

QTypeExp::~QTypeExp()
{
  delete(qc_);

}

void QTypeExp::accept(Visitor *v)
{
  v->visitQTypeExp(this);
}

QTypeExp *QTypeExp::clone() const
{
  return new QTypeExp(*this);
}



/********************   EFunCall    ********************/
EFunCall::EFunCall(Id p1, ListExp *p2)
{
  id_ = p1;
  listexp_ = p2;

}

EFunCall::EFunCall(const EFunCall & other)
{
  id_ = other.id_;
  listexp_ = other.listexp_->clone();

}

EFunCall &EFunCall::operator=(const EFunCall & other)
{
  EFunCall tmp(other);
  swap(tmp);
  return *this;
}

void EFunCall::swap(EFunCall & other)
{
  std::swap(id_, other.id_);
  std::swap(listexp_, other.listexp_);

}

EFunCall::~EFunCall()
{
  delete(listexp_);

}

void EFunCall::accept(Visitor *v)
{
  v->visitEFunCall(this);
}

EFunCall *EFunCall::clone() const
{
  return new EFunCall(*this);
}



/********************   EColon    ********************/
EColon::EColon(Id p1, Exp *p2)
{
  id_ = p1;
  exp_ = p2;

}

EColon::EColon(const EColon & other)
{
  id_ = other.id_;
  exp_ = other.exp_->clone();

}

EColon &EColon::operator=(const EColon & other)
{
  EColon tmp(other);
  swap(tmp);
  return *this;
}

void EColon::swap(EColon & other)
{
  std::swap(id_, other.id_);
  std::swap(exp_, other.exp_);

}

EColon::~EColon()
{
  delete(exp_);

}

void EColon::accept(Visitor *v)
{
  v->visitEColon(this);
}

EColon *EColon::clone() const
{
  return new EColon(*this);
}



/********************   EInd    ********************/
EInd::EInd(Id p1, ListExp *p2)
{
  id_ = p1;
  listexp_ = p2;

}

EInd::EInd(const EInd & other)
{
  id_ = other.id_;
  listexp_ = other.listexp_->clone();

}

EInd &EInd::operator=(const EInd & other)
{
  EInd tmp(other);
  swap(tmp);
  return *this;
}

void EInd::swap(EInd & other)
{
  std::swap(id_, other.id_);
  std::swap(listexp_, other.listexp_);

}

EInd::~EInd()
{
  delete(listexp_);

}

void EInd::accept(Visitor *v)
{
  v->visitEInd(this);
}

EInd *EInd::clone() const
{
  return new EInd(*this);
}



/********************   EPIncr    ********************/
EPIncr::EPIncr(Exp *p1)
{
  exp_ = p1;

}

EPIncr::EPIncr(const EPIncr & other)
{
  exp_ = other.exp_->clone();

}

EPIncr &EPIncr::operator=(const EPIncr & other)
{
  EPIncr tmp(other);
  swap(tmp);
  return *this;
}

void EPIncr::swap(EPIncr & other)
{
  std::swap(exp_, other.exp_);

}

EPIncr::~EPIncr()
{
  delete(exp_);

}

void EPIncr::accept(Visitor *v)
{
  v->visitEPIncr(this);
}

EPIncr *EPIncr::clone() const
{
  return new EPIncr(*this);
}



/********************   EPDecr    ********************/
EPDecr::EPDecr(Exp *p1)
{
  exp_ = p1;

}

EPDecr::EPDecr(const EPDecr & other)
{
  exp_ = other.exp_->clone();

}

EPDecr &EPDecr::operator=(const EPDecr & other)
{
  EPDecr tmp(other);
  swap(tmp);
  return *this;
}

void EPDecr::swap(EPDecr & other)
{
  std::swap(exp_, other.exp_);

}

EPDecr::~EPDecr()
{
  delete(exp_);

}

void EPDecr::accept(Visitor *v)
{
  v->visitEPDecr(this);
}

EPDecr *EPDecr::clone() const
{
  return new EPDecr(*this);
}



/********************   EDot    ********************/
EDot::EDot(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EDot::EDot(const EDot & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EDot &EDot::operator=(const EDot & other)
{
  EDot tmp(other);
  swap(tmp);
  return *this;
}

void EDot::swap(EDot & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EDot::~EDot()
{
  delete(exp_1);
  delete(exp_2);

}

void EDot::accept(Visitor *v)
{
  v->visitEDot(this);
}

EDot *EDot::clone() const
{
  return new EDot(*this);
}



/********************   EArrow    ********************/
EArrow::EArrow(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EArrow::EArrow(const EArrow & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EArrow &EArrow::operator=(const EArrow & other)
{
  EArrow tmp(other);
  swap(tmp);
  return *this;
}

void EArrow::swap(EArrow & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EArrow::~EArrow()
{
  delete(exp_1);
  delete(exp_2);

}

void EArrow::accept(Visitor *v)
{
  v->visitEArrow(this);
}

EArrow *EArrow::clone() const
{
  return new EArrow(*this);
}



/********************   EDRef    ********************/
EDRef::EDRef(Exp *p1)
{
  exp_ = p1;

}

EDRef::EDRef(const EDRef & other)
{
  exp_ = other.exp_->clone();

}

EDRef &EDRef::operator=(const EDRef & other)
{
  EDRef tmp(other);
  swap(tmp);
  return *this;
}

void EDRef::swap(EDRef & other)
{
  std::swap(exp_, other.exp_);

}

EDRef::~EDRef()
{
  delete(exp_);

}

void EDRef::accept(Visitor *v)
{
  v->visitEDRef(this);
}

EDRef *EDRef::clone() const
{
  return new EDRef(*this);
}



/********************   EIncr    ********************/
EIncr::EIncr(Exp *p1)
{
  exp_ = p1;

}

EIncr::EIncr(const EIncr & other)
{
  exp_ = other.exp_->clone();

}

EIncr &EIncr::operator=(const EIncr & other)
{
  EIncr tmp(other);
  swap(tmp);
  return *this;
}

void EIncr::swap(EIncr & other)
{
  std::swap(exp_, other.exp_);

}

EIncr::~EIncr()
{
  delete(exp_);

}

void EIncr::accept(Visitor *v)
{
  v->visitEIncr(this);
}

EIncr *EIncr::clone() const
{
  return new EIncr(*this);
}



/********************   EDecr    ********************/
EDecr::EDecr(Exp *p1)
{
  exp_ = p1;

}

EDecr::EDecr(const EDecr & other)
{
  exp_ = other.exp_->clone();

}

EDecr &EDecr::operator=(const EDecr & other)
{
  EDecr tmp(other);
  swap(tmp);
  return *this;
}

void EDecr::swap(EDecr & other)
{
  std::swap(exp_, other.exp_);

}

EDecr::~EDecr()
{
  delete(exp_);

}

void EDecr::accept(Visitor *v)
{
  v->visitEDecr(this);
}

EDecr *EDecr::clone() const
{
  return new EDecr(*this);
}



/********************   ENeg    ********************/
ENeg::ENeg(Exp *p1)
{
  exp_ = p1;

}

ENeg::ENeg(const ENeg & other)
{
  exp_ = other.exp_->clone();

}

ENeg &ENeg::operator=(const ENeg & other)
{
  ENeg tmp(other);
  swap(tmp);
  return *this;
}

void ENeg::swap(ENeg & other)
{
  std::swap(exp_, other.exp_);

}

ENeg::~ENeg()
{
  delete(exp_);

}

void ENeg::accept(Visitor *v)
{
  v->visitENeg(this);
}

ENeg *ENeg::clone() const
{
  return new ENeg(*this);
}



/********************   EMod    ********************/
EMod::EMod(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EMod::EMod(const EMod & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EMod &EMod::operator=(const EMod & other)
{
  EMod tmp(other);
  swap(tmp);
  return *this;
}

void EMod::swap(EMod & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EMod::~EMod()
{
  delete(exp_1);
  delete(exp_2);

}

void EMod::accept(Visitor *v)
{
  v->visitEMod(this);
}

EMod *EMod::clone() const
{
  return new EMod(*this);
}



/********************   ETimes    ********************/
ETimes::ETimes(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

ETimes::ETimes(const ETimes & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

ETimes &ETimes::operator=(const ETimes & other)
{
  ETimes tmp(other);
  swap(tmp);
  return *this;
}

void ETimes::swap(ETimes & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ETimes::~ETimes()
{
  delete(exp_1);
  delete(exp_2);

}

void ETimes::accept(Visitor *v)
{
  v->visitETimes(this);
}

ETimes *ETimes::clone() const
{
  return new ETimes(*this);
}



/********************   EDiv    ********************/
EDiv::EDiv(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EDiv::EDiv(const EDiv & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EDiv &EDiv::operator=(const EDiv & other)
{
  EDiv tmp(other);
  swap(tmp);
  return *this;
}

void EDiv::swap(EDiv & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EDiv::~EDiv()
{
  delete(exp_1);
  delete(exp_2);

}

void EDiv::accept(Visitor *v)
{
  v->visitEDiv(this);
}

EDiv *EDiv::clone() const
{
  return new EDiv(*this);
}



/********************   EPlus    ********************/
EPlus::EPlus(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EPlus::EPlus(const EPlus & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EPlus &EPlus::operator=(const EPlus & other)
{
  EPlus tmp(other);
  swap(tmp);
  return *this;
}

void EPlus::swap(EPlus & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EPlus::~EPlus()
{
  delete(exp_1);
  delete(exp_2);

}

void EPlus::accept(Visitor *v)
{
  v->visitEPlus(this);
}

EPlus *EPlus::clone() const
{
  return new EPlus(*this);
}



/********************   EMinus    ********************/
EMinus::EMinus(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EMinus::EMinus(const EMinus & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EMinus &EMinus::operator=(const EMinus & other)
{
  EMinus tmp(other);
  swap(tmp);
  return *this;
}

void EMinus::swap(EMinus & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EMinus::~EMinus()
{
  delete(exp_1);
  delete(exp_2);

}

void EMinus::accept(Visitor *v)
{
  v->visitEMinus(this);
}

EMinus *EMinus::clone() const
{
  return new EMinus(*this);
}



/********************   ESl    ********************/
ESl::ESl(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

ESl::ESl(const ESl & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

ESl &ESl::operator=(const ESl & other)
{
  ESl tmp(other);
  swap(tmp);
  return *this;
}

void ESl::swap(ESl & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ESl::~ESl()
{
  delete(exp_1);
  delete(exp_2);

}

void ESl::accept(Visitor *v)
{
  v->visitESl(this);
}

ESl *ESl::clone() const
{
  return new ESl(*this);
}



/********************   ESr    ********************/
ESr::ESr(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

ESr::ESr(const ESr & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

ESr &ESr::operator=(const ESr & other)
{
  ESr tmp(other);
  swap(tmp);
  return *this;
}

void ESr::swap(ESr & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ESr::~ESr()
{
  delete(exp_1);
  delete(exp_2);

}

void ESr::accept(Visitor *v)
{
  v->visitESr(this);
}

ESr *ESr::clone() const
{
  return new ESr(*this);
}



/********************   ELt    ********************/
ELt::ELt(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

ELt::ELt(const ELt & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

ELt &ELt::operator=(const ELt & other)
{
  ELt tmp(other);
  swap(tmp);
  return *this;
}

void ELt::swap(ELt & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ELt::~ELt()
{
  delete(exp_1);
  delete(exp_2);

}

void ELt::accept(Visitor *v)
{
  v->visitELt(this);
}

ELt *ELt::clone() const
{
  return new ELt(*this);
}



/********************   EGt    ********************/
EGt::EGt(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EGt::EGt(const EGt & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EGt &EGt::operator=(const EGt & other)
{
  EGt tmp(other);
  swap(tmp);
  return *this;
}

void EGt::swap(EGt & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EGt::~EGt()
{
  delete(exp_1);
  delete(exp_2);

}

void EGt::accept(Visitor *v)
{
  v->visitEGt(this);
}

EGt *EGt::clone() const
{
  return new EGt(*this);
}



/********************   ENewLin    ********************/
ENewLin::ENewLin(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

ENewLin::ENewLin(const ENewLin & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

ENewLin &ENewLin::operator=(const ENewLin & other)
{
  ENewLin tmp(other);
  swap(tmp);
  return *this;
}

void ENewLin::swap(ENewLin & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ENewLin::~ENewLin()
{
  delete(exp_1);
  delete(exp_2);

}

void ENewLin::accept(Visitor *v)
{
  v->visitENewLin(this);
}

ENewLin *ENewLin::clone() const
{
  return new ENewLin(*this);
}



/********************   EEqual    ********************/
EEqual::EEqual(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EEqual::EEqual(const EEqual & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EEqual &EEqual::operator=(const EEqual & other)
{
  EEqual tmp(other);
  swap(tmp);
  return *this;
}

void EEqual::swap(EEqual & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EEqual::~EEqual()
{
  delete(exp_1);
  delete(exp_2);

}

void EEqual::accept(Visitor *v)
{
  v->visitEEqual(this);
}

EEqual *EEqual::clone() const
{
  return new EEqual(*this);
}



/********************   ELtEq    ********************/
ELtEq::ELtEq(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

ELtEq::ELtEq(const ELtEq & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

ELtEq &ELtEq::operator=(const ELtEq & other)
{
  ELtEq tmp(other);
  swap(tmp);
  return *this;
}

void ELtEq::swap(ELtEq & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ELtEq::~ELtEq()
{
  delete(exp_1);
  delete(exp_2);

}

void ELtEq::accept(Visitor *v)
{
  v->visitELtEq(this);
}

ELtEq *ELtEq::clone() const
{
  return new ELtEq(*this);
}



/********************   EGtEq    ********************/
EGtEq::EGtEq(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EGtEq::EGtEq(const EGtEq & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EGtEq &EGtEq::operator=(const EGtEq & other)
{
  EGtEq tmp(other);
  swap(tmp);
  return *this;
}

void EGtEq::swap(EGtEq & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EGtEq::~EGtEq()
{
  delete(exp_1);
  delete(exp_2);

}

void EGtEq::accept(Visitor *v)
{
  v->visitEGtEq(this);
}

EGtEq *EGtEq::clone() const
{
  return new EGtEq(*this);
}



/********************   EEq    ********************/
EEq::EEq(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EEq::EEq(const EEq & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EEq &EEq::operator=(const EEq & other)
{
  EEq tmp(other);
  swap(tmp);
  return *this;
}

void EEq::swap(EEq & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EEq::~EEq()
{
  delete(exp_1);
  delete(exp_2);

}

void EEq::accept(Visitor *v)
{
  v->visitEEq(this);
}

EEq *EEq::clone() const
{
  return new EEq(*this);
}



/********************   ENEq    ********************/
ENEq::ENEq(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

ENEq::ENEq(const ENEq & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

ENEq &ENEq::operator=(const ENEq & other)
{
  ENEq tmp(other);
  swap(tmp);
  return *this;
}

void ENEq::swap(ENEq & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ENEq::~ENEq()
{
  delete(exp_1);
  delete(exp_2);

}

void ENEq::accept(Visitor *v)
{
  v->visitENEq(this);
}

ENEq *ENEq::clone() const
{
  return new ENEq(*this);
}



/********************   EAnd    ********************/
EAnd::EAnd(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EAnd::EAnd(const EAnd & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EAnd &EAnd::operator=(const EAnd & other)
{
  EAnd tmp(other);
  swap(tmp);
  return *this;
}

void EAnd::swap(EAnd & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EAnd::~EAnd()
{
  delete(exp_1);
  delete(exp_2);

}

void EAnd::accept(Visitor *v)
{
  v->visitEAnd(this);
}

EAnd *EAnd::clone() const
{
  return new EAnd(*this);
}



/********************   EOr    ********************/
EOr::EOr(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EOr::EOr(const EOr & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EOr &EOr::operator=(const EOr & other)
{
  EOr tmp(other);
  swap(tmp);
  return *this;
}

void EOr::swap(EOr & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EOr::~EOr()
{
  delete(exp_1);
  delete(exp_2);

}

void EOr::accept(Visitor *v)
{
  v->visitEOr(this);
}

EOr *EOr::clone() const
{
  return new EOr(*this);
}



/********************   ECond    ********************/
ECond::ECond(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

ECond::ECond(const ECond & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

ECond &ECond::operator=(const ECond & other)
{
  ECond tmp(other);
  swap(tmp);
  return *this;
}

void ECond::swap(ECond & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ECond::~ECond()
{
  delete(exp_1);
  delete(exp_2);

}

void ECond::accept(Visitor *v)
{
  v->visitECond(this);
}

ECond *ECond::clone() const
{
  return new ECond(*this);
}



/********************   ECond2    ********************/
ECond2::ECond2(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

ECond2::ECond2(const ECond2 & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

ECond2 &ECond2::operator=(const ECond2 & other)
{
  ECond2 tmp(other);
  swap(tmp);
  return *this;
}

void ECond2::swap(ECond2 & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ECond2::~ECond2()
{
  delete(exp_1);
  delete(exp_2);

}

void ECond2::accept(Visitor *v)
{
  v->visitECond2(this);
}

ECond2 *ECond2::clone() const
{
  return new ECond2(*this);
}



/********************   EThrow    ********************/
EThrow::EThrow(Exp *p1)
{
  exp_ = p1;

}

EThrow::EThrow(const EThrow & other)
{
  exp_ = other.exp_->clone();

}

EThrow &EThrow::operator=(const EThrow & other)
{
  EThrow tmp(other);
  swap(tmp);
  return *this;
}

void EThrow::swap(EThrow & other)
{
  std::swap(exp_, other.exp_);

}

EThrow::~EThrow()
{
  delete(exp_);

}

void EThrow::accept(Visitor *v)
{
  v->visitEThrow(this);
}

EThrow *EThrow::clone() const
{
  return new EThrow(*this);
}




/********************   ListDef    ********************/

void ListDef::accept(Visitor *v)
{
  v->visitListDef(this);
}


ListDef *ListDef::clone() const
{
  return new ListDef(*this);
}


/********************   ListArg    ********************/

void ListArg::accept(Visitor *v)
{
  v->visitListArg(this);
}


ListArg *ListArg::clone() const
{
  return new ListArg(*this);
}


/********************   ListStm    ********************/

void ListStm::accept(Visitor *v)
{
  v->visitListStm(this);
}


ListStm *ListStm::clone() const
{
  return new ListStm(*this);
}


/********************   ListType    ********************/

void ListType::accept(Visitor *v)
{
  v->visitListType(this);
}


ListType *ListType::clone() const
{
  return new ListType(*this);
}


/********************   ListExp    ********************/

void ListExp::accept(Visitor *v)
{
  v->visitListExp(this);
}


ListExp *ListExp::clone() const
{
  return new ListExp(*this);
}


/********************   ListId    ********************/

void ListId::accept(Visitor *v)
{
  v->visitListId(this);
}


ListId *ListId::clone() const
{
  return new ListId(*this);
}




