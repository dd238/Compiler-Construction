#ifndef ABSYN_HEADER
#define ABSYN_HEADER

#include<string>
#include<vector>

//C++ Abstract Syntax Interface generated by the BNF Converter.

/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef std::string String;
typedef std::string Ident;


typedef std::string Id;


/********************   Forward Declarations    ********************/

class Program;
class Def;
class Arg;
class Stm;
class QC;
class Name;
class Tmp;
class Type;
class Exp;
class PDefs;
class DFun;
class DUse;
class DUsing2;
class DTypDef;
class DDecl;
class AFunc;
class ADecl;
class SExp;
class STypDef;
class SWhile;
class SBlock;
class SIf;
class SIfElse;
class SFor;
class SReturn;
class SDoWhile;
class QualConst;
class QualConst2;
class Name1;
class Name2;
class Template;
class TQC;
class TAddress;
class TConst;
class EType;
class EString;
class EInt;
class EId;
class EChar;
class QTypeExp;
class EFunCall;
class EColon;
class EInd;
class EPIncr;
class EPDecr;
class EDot;
class EArrow;
class EDRef;
class EIncr;
class EDecr;
class ENeg;
class EMod;
class ETimes;
class EDiv;
class EPlus;
class EMinus;
class ESl;
class ESr;
class ELt;
class EGt;
class ENewLin;
class EEqual;
class ELtEq;
class EGtEq;
class EEq;
class ENEq;
class EAnd;
class EOr;
class ECond;
class ECond2;
class EThrow;
class Type_bool;
class Type_int;
class Type_double;
class Type_void;
class Type_string;
class Type_vector;
class Type_map;
class ListDef;
class ListArg;
class ListStm;
class ListType;
class ListExp;
class ListId;


/********************   Visitor Interfaces    ********************/
class Visitor
{
public:
  virtual ~Visitor() {}
  virtual void visitProgram(Program *p) = 0;
  virtual void visitDef(Def *p) = 0;
  virtual void visitArg(Arg *p) = 0;
  virtual void visitStm(Stm *p) = 0;
  virtual void visitQC(QC *p) = 0;
  virtual void visitName(Name *p) = 0;
  virtual void visitTmp(Tmp *p) = 0;
  virtual void visitType(Type *p) = 0;
  virtual void visitExp(Exp *p) = 0;
  virtual void visitPDefs(PDefs *p) = 0;
  virtual void visitDFun(DFun *p) = 0;
  virtual void visitDUse(DUse *p) = 0;
  virtual void visitDUsing2(DUsing2 *p) = 0;
  virtual void visitDTypDef(DTypDef *p) = 0;
  virtual void visitDDecl(DDecl *p) = 0;
  virtual void visitAFunc(AFunc *p) = 0;
  virtual void visitADecl(ADecl *p) = 0;
  virtual void visitSExp(SExp *p) = 0;
  virtual void visitSTypDef(STypDef *p) = 0;
  virtual void visitSWhile(SWhile *p) = 0;
  virtual void visitSBlock(SBlock *p) = 0;
  virtual void visitSIf(SIf *p) = 0;
  virtual void visitSIfElse(SIfElse *p) = 0;
  virtual void visitSFor(SFor *p) = 0;
  virtual void visitSReturn(SReturn *p) = 0;
  virtual void visitSDoWhile(SDoWhile *p) = 0;
  virtual void visitQualConst(QualConst *p) = 0;
  virtual void visitQualConst2(QualConst2 *p) = 0;
  virtual void visitName1(Name1 *p) = 0;
  virtual void visitName2(Name2 *p) = 0;
  virtual void visitTemplate(Template *p) = 0;
  virtual void visitTQC(TQC *p) = 0;
  virtual void visitTAddress(TAddress *p) = 0;
  virtual void visitTConst(TConst *p) = 0;
  virtual void visitEType(EType *p) = 0;
  virtual void visitEString(EString *p) = 0;
  virtual void visitEInt(EInt *p) = 0;
  virtual void visitEId(EId *p) = 0;
  virtual void visitEChar(EChar *p) = 0;
  virtual void visitQTypeExp(QTypeExp *p) = 0;
  virtual void visitEFunCall(EFunCall *p) = 0;
  virtual void visitEColon(EColon *p) = 0;
  virtual void visitEInd(EInd *p) = 0;
  virtual void visitEPIncr(EPIncr *p) = 0;
  virtual void visitEPDecr(EPDecr *p) = 0;
  virtual void visitEDot(EDot *p) = 0;
  virtual void visitEArrow(EArrow *p) = 0;
  virtual void visitEDRef(EDRef *p) = 0;
  virtual void visitEIncr(EIncr *p) = 0;
  virtual void visitEDecr(EDecr *p) = 0;
  virtual void visitENeg(ENeg *p) = 0;
  virtual void visitEMod(EMod *p) = 0;
  virtual void visitETimes(ETimes *p) = 0;
  virtual void visitEDiv(EDiv *p) = 0;
  virtual void visitEPlus(EPlus *p) = 0;
  virtual void visitEMinus(EMinus *p) = 0;
  virtual void visitESl(ESl *p) = 0;
  virtual void visitESr(ESr *p) = 0;
  virtual void visitELt(ELt *p) = 0;
  virtual void visitEGt(EGt *p) = 0;
  virtual void visitENewLin(ENewLin *p) = 0;
  virtual void visitEEqual(EEqual *p) = 0;
  virtual void visitELtEq(ELtEq *p) = 0;
  virtual void visitEGtEq(EGtEq *p) = 0;
  virtual void visitEEq(EEq *p) = 0;
  virtual void visitENEq(ENEq *p) = 0;
  virtual void visitEAnd(EAnd *p) = 0;
  virtual void visitEOr(EOr *p) = 0;
  virtual void visitECond(ECond *p) = 0;
  virtual void visitECond2(ECond2 *p) = 0;
  virtual void visitEThrow(EThrow *p) = 0;
  virtual void visitType_bool(Type_bool *p) = 0;
  virtual void visitType_int(Type_int *p) = 0;
  virtual void visitType_double(Type_double *p) = 0;
  virtual void visitType_void(Type_void *p) = 0;
  virtual void visitType_string(Type_string *p) = 0;
  virtual void visitType_vector(Type_vector *p) = 0;
  virtual void visitType_map(Type_map *p) = 0;
  virtual void visitListDef(ListDef *p) = 0;
  virtual void visitListArg(ListArg *p) = 0;
  virtual void visitListStm(ListStm *p) = 0;
  virtual void visitListType(ListType *p) = 0;
  virtual void visitListExp(ListExp *p) = 0;
  virtual void visitListId(ListId *p) = 0;


  virtual void visitInteger(Integer x) = 0;
  virtual void visitChar(Char x) = 0;
  virtual void visitDouble(Double x) = 0;
  virtual void visitString(String x) = 0;
  virtual void visitIdent(Ident x) = 0;
  virtual void visitId(Id x) = 0;

};


class Visitable
{
 public:
  virtual ~Visitable() {}
  virtual void accept(Visitor *v) = 0;
};


/********************   Abstract Syntax Classes    ********************/

class Program : public Visitable
{
public:
  virtual Program *clone() const = 0;

};

class Def : public Visitable
{
public:
  virtual Def *clone() const = 0;

};

class Arg : public Visitable
{
public:
  virtual Arg *clone() const = 0;

};

class Stm : public Visitable
{
public:
  virtual Stm *clone() const = 0;

};

class QC : public Visitable
{
public:
  virtual QC *clone() const = 0;

};

class Name : public Visitable
{
public:
  virtual Name *clone() const = 0;

};

class Tmp : public Visitable
{
public:
  virtual Tmp *clone() const = 0;

};

class Type : public Visitable
{
public:
  virtual Type *clone() const = 0;

};

class Exp : public Visitable
{
public:
  virtual Exp *clone() const = 0;

};



class PDefs : public Program
{
public:
  ListDef *listdef_;

  PDefs(const PDefs &);
  PDefs &operator=(const PDefs &);
  PDefs(ListDef *p1);
  ~PDefs();
  virtual void accept(Visitor *v);
  virtual PDefs *clone() const;
  void swap(PDefs &);
};

class DFun : public Def
{
public:
  Type *type_;
  Id id_;
  ListArg *listarg_;
  ListStm *liststm_;

  DFun(const DFun &);
  DFun &operator=(const DFun &);
  DFun(Type *p1, Id p2, ListArg *p3, ListStm *p4);
  ~DFun();
  virtual void accept(Visitor *v);
  virtual DFun *clone() const;
  void swap(DFun &);
};

class DUse : public Def
{
public:
  Id id_1;
  Id id_2;

  DUse(const DUse &);
  DUse &operator=(const DUse &);
  DUse(Id p1, Id p2);
  ~DUse();
  virtual void accept(Visitor *v);
  virtual DUse *clone() const;
  void swap(DUse &);
};

class DUsing2 : public Def
{
public:
  Id id_;
  Type *type_;

  DUsing2(const DUsing2 &);
  DUsing2 &operator=(const DUsing2 &);
  DUsing2(Id p1, Type *p2);
  ~DUsing2();
  virtual void accept(Visitor *v);
  virtual DUsing2 *clone() const;
  void swap(DUsing2 &);
};

class DTypDef : public Def
{
public:
  Type *type_;
  Id id_;

  DTypDef(const DTypDef &);
  DTypDef &operator=(const DTypDef &);
  DTypDef(Type *p1, Id p2);
  ~DTypDef();
  virtual void accept(Visitor *v);
  virtual DTypDef *clone() const;
  void swap(DTypDef &);
};

class DDecl : public Def
{
public:
  Type *type_;
  Id id_;
  ListArg *listarg_;

  DDecl(const DDecl &);
  DDecl &operator=(const DDecl &);
  DDecl(Type *p1, Id p2, ListArg *p3);
  ~DDecl();
  virtual void accept(Visitor *v);
  virtual DDecl *clone() const;
  void swap(DDecl &);
};

class AFunc : public Arg
{
public:
  Type *type_;

  AFunc(const AFunc &);
  AFunc &operator=(const AFunc &);
  AFunc(Type *p1);
  ~AFunc();
  virtual void accept(Visitor *v);
  virtual AFunc *clone() const;
  void swap(AFunc &);
};

class ADecl : public Arg
{
public:
  Type *type_;
  Id id_;

  ADecl(const ADecl &);
  ADecl &operator=(const ADecl &);
  ADecl(Type *p1, Id p2);
  ~ADecl();
  virtual void accept(Visitor *v);
  virtual ADecl *clone() const;
  void swap(ADecl &);
};

class SExp : public Stm
{
public:
  Exp *exp_;

  SExp(const SExp &);
  SExp &operator=(const SExp &);
  SExp(Exp *p1);
  ~SExp();
  virtual void accept(Visitor *v);
  virtual SExp *clone() const;
  void swap(SExp &);
};

class STypDef : public Stm
{
public:
  Type *type_;
  Id id_;

  STypDef(const STypDef &);
  STypDef &operator=(const STypDef &);
  STypDef(Type *p1, Id p2);
  ~STypDef();
  virtual void accept(Visitor *v);
  virtual STypDef *clone() const;
  void swap(STypDef &);
};

class SWhile : public Stm
{
public:
  Exp *exp_;
  Stm *stm_;

  SWhile(const SWhile &);
  SWhile &operator=(const SWhile &);
  SWhile(Exp *p1, Stm *p2);
  ~SWhile();
  virtual void accept(Visitor *v);
  virtual SWhile *clone() const;
  void swap(SWhile &);
};

class SBlock : public Stm
{
public:
  ListStm *liststm_;

  SBlock(const SBlock &);
  SBlock &operator=(const SBlock &);
  SBlock(ListStm *p1);
  ~SBlock();
  virtual void accept(Visitor *v);
  virtual SBlock *clone() const;
  void swap(SBlock &);
};

class SIf : public Stm
{
public:
  Exp *exp_;
  Stm *stm_;

  SIf(const SIf &);
  SIf &operator=(const SIf &);
  SIf(Exp *p1, Stm *p2);
  ~SIf();
  virtual void accept(Visitor *v);
  virtual SIf *clone() const;
  void swap(SIf &);
};

class SIfElse : public Stm
{
public:
  Exp *exp_;
  Stm *stm_1;
  Stm *stm_2;

  SIfElse(const SIfElse &);
  SIfElse &operator=(const SIfElse &);
  SIfElse(Exp *p1, Stm *p2, Stm *p3);
  ~SIfElse();
  virtual void accept(Visitor *v);
  virtual SIfElse *clone() const;
  void swap(SIfElse &);
};

class SFor : public Stm
{
public:
  ListExp *listexp_;
  Stm *stm_;

  SFor(const SFor &);
  SFor &operator=(const SFor &);
  SFor(ListExp *p1, Stm *p2);
  ~SFor();
  virtual void accept(Visitor *v);
  virtual SFor *clone() const;
  void swap(SFor &);
};

class SReturn : public Stm
{
public:
  Exp *exp_;

  SReturn(const SReturn &);
  SReturn &operator=(const SReturn &);
  SReturn(Exp *p1);
  ~SReturn();
  virtual void accept(Visitor *v);
  virtual SReturn *clone() const;
  void swap(SReturn &);
};

class SDoWhile : public Stm
{
public:
  Stm *stm_;
  Exp *exp_;

  SDoWhile(const SDoWhile &);
  SDoWhile &operator=(const SDoWhile &);
  SDoWhile(Stm *p1, Exp *p2);
  ~SDoWhile();
  virtual void accept(Visitor *v);
  virtual SDoWhile *clone() const;
  void swap(SDoWhile &);
};

class QualConst : public QC
{
public:
  Name *name_;

  QualConst(const QualConst &);
  QualConst &operator=(const QualConst &);
  QualConst(Name *p1);
  ~QualConst();
  virtual void accept(Visitor *v);
  virtual QualConst *clone() const;
  void swap(QualConst &);
};

class QualConst2 : public QC
{
public:
  Name *name_;
  QC *qc_;

  QualConst2(const QualConst2 &);
  QualConst2 &operator=(const QualConst2 &);
  QualConst2(Name *p1, QC *p2);
  ~QualConst2();
  virtual void accept(Visitor *v);
  virtual QualConst2 *clone() const;
  void swap(QualConst2 &);
};

class Name1 : public Name
{
public:
  Id id_;

  Name1(const Name1 &);
  Name1 &operator=(const Name1 &);
  Name1(Id p1);
  ~Name1();
  virtual void accept(Visitor *v);
  virtual Name1 *clone() const;
  void swap(Name1 &);
};

class Name2 : public Name
{
public:
  Tmp *tmp_;

  Name2(const Name2 &);
  Name2 &operator=(const Name2 &);
  Name2(Tmp *p1);
  ~Name2();
  virtual void accept(Visitor *v);
  virtual Name2 *clone() const;
  void swap(Name2 &);
};

class Template : public Tmp
{
public:
  Type *type_;
  ListType *listtype_;

  Template(const Template &);
  Template &operator=(const Template &);
  Template(Type *p1, ListType *p2);
  ~Template();
  virtual void accept(Visitor *v);
  virtual Template *clone() const;
  void swap(Template &);
};

class TQC : public Type
{
public:
  QC *qc_;

  TQC(const TQC &);
  TQC &operator=(const TQC &);
  TQC(QC *p1);
  ~TQC();
  virtual void accept(Visitor *v);
  virtual TQC *clone() const;
  void swap(TQC &);
};

class TAddress : public Type
{
public:
  Type *type_;

  TAddress(const TAddress &);
  TAddress &operator=(const TAddress &);
  TAddress(Type *p1);
  ~TAddress();
  virtual void accept(Visitor *v);
  virtual TAddress *clone() const;
  void swap(TAddress &);
};

class TConst : public Type
{
public:
  Type *type_;

  TConst(const TConst &);
  TConst &operator=(const TConst &);
  TConst(Type *p1);
  ~TConst();
  virtual void accept(Visitor *v);
  virtual TConst *clone() const;
  void swap(TConst &);
};

class Type_bool : public Type
{
public:

  Type_bool(const Type_bool &);
  Type_bool &operator=(const Type_bool &);
  Type_bool();
  ~Type_bool();
  virtual void accept(Visitor *v);
  virtual Type_bool *clone() const;
  void swap(Type_bool &);
};

class Type_int : public Type
{
public:

  Type_int(const Type_int &);
  Type_int &operator=(const Type_int &);
  Type_int();
  ~Type_int();
  virtual void accept(Visitor *v);
  virtual Type_int *clone() const;
  void swap(Type_int &);
};

class Type_double : public Type
{
public:

  Type_double(const Type_double &);
  Type_double &operator=(const Type_double &);
  Type_double();
  ~Type_double();
  virtual void accept(Visitor *v);
  virtual Type_double *clone() const;
  void swap(Type_double &);
};

class Type_void : public Type
{
public:

  Type_void(const Type_void &);
  Type_void &operator=(const Type_void &);
  Type_void();
  ~Type_void();
  virtual void accept(Visitor *v);
  virtual Type_void *clone() const;
  void swap(Type_void &);
};

class Type_string : public Type
{
public:

  Type_string(const Type_string &);
  Type_string &operator=(const Type_string &);
  Type_string();
  ~Type_string();
  virtual void accept(Visitor *v);
  virtual Type_string *clone() const;
  void swap(Type_string &);
};

class Type_vector : public Type
{
public:

  Type_vector(const Type_vector &);
  Type_vector &operator=(const Type_vector &);
  Type_vector();
  ~Type_vector();
  virtual void accept(Visitor *v);
  virtual Type_vector *clone() const;
  void swap(Type_vector &);
};

class Type_map : public Type
{
public:

  Type_map(const Type_map &);
  Type_map &operator=(const Type_map &);
  Type_map();
  ~Type_map();
  virtual void accept(Visitor *v);
  virtual Type_map *clone() const;
  void swap(Type_map &);
};

class EType : public Exp
{
public:
  Type *type_;
  ListId *listid_;

  EType(const EType &);
  EType &operator=(const EType &);
  EType(Type *p1, ListId *p2);
  ~EType();
  virtual void accept(Visitor *v);
  virtual EType *clone() const;
  void swap(EType &);
};

class EString : public Exp
{
public:
  String string_;

  EString(const EString &);
  EString &operator=(const EString &);
  EString(String p1);
  ~EString();
  virtual void accept(Visitor *v);
  virtual EString *clone() const;
  void swap(EString &);
};

class EInt : public Exp
{
public:
  Integer integer_;

  EInt(const EInt &);
  EInt &operator=(const EInt &);
  EInt(Integer p1);
  ~EInt();
  virtual void accept(Visitor *v);
  virtual EInt *clone() const;
  void swap(EInt &);
};

class EId : public Exp
{
public:
  Id id_;

  EId(const EId &);
  EId &operator=(const EId &);
  EId(Id p1);
  ~EId();
  virtual void accept(Visitor *v);
  virtual EId *clone() const;
  void swap(EId &);
};

class EChar : public Exp
{
public:
  Char char_;

  EChar(const EChar &);
  EChar &operator=(const EChar &);
  EChar(Char p1);
  ~EChar();
  virtual void accept(Visitor *v);
  virtual EChar *clone() const;
  void swap(EChar &);
};

class QTypeExp : public Exp
{
public:
  QC *qc_;

  QTypeExp(const QTypeExp &);
  QTypeExp &operator=(const QTypeExp &);
  QTypeExp(QC *p1);
  ~QTypeExp();
  virtual void accept(Visitor *v);
  virtual QTypeExp *clone() const;
  void swap(QTypeExp &);
};

class EFunCall : public Exp
{
public:
  Id id_;
  ListExp *listexp_;

  EFunCall(const EFunCall &);
  EFunCall &operator=(const EFunCall &);
  EFunCall(Id p1, ListExp *p2);
  ~EFunCall();
  virtual void accept(Visitor *v);
  virtual EFunCall *clone() const;
  void swap(EFunCall &);
};

class EColon : public Exp
{
public:
  Id id_;
  Exp *exp_;

  EColon(const EColon &);
  EColon &operator=(const EColon &);
  EColon(Id p1, Exp *p2);
  ~EColon();
  virtual void accept(Visitor *v);
  virtual EColon *clone() const;
  void swap(EColon &);
};

class EInd : public Exp
{
public:
  Id id_;
  ListExp *listexp_;

  EInd(const EInd &);
  EInd &operator=(const EInd &);
  EInd(Id p1, ListExp *p2);
  ~EInd();
  virtual void accept(Visitor *v);
  virtual EInd *clone() const;
  void swap(EInd &);
};

class EPIncr : public Exp
{
public:
  Exp *exp_;

  EPIncr(const EPIncr &);
  EPIncr &operator=(const EPIncr &);
  EPIncr(Exp *p1);
  ~EPIncr();
  virtual void accept(Visitor *v);
  virtual EPIncr *clone() const;
  void swap(EPIncr &);
};

class EPDecr : public Exp
{
public:
  Exp *exp_;

  EPDecr(const EPDecr &);
  EPDecr &operator=(const EPDecr &);
  EPDecr(Exp *p1);
  ~EPDecr();
  virtual void accept(Visitor *v);
  virtual EPDecr *clone() const;
  void swap(EPDecr &);
};

class EDot : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EDot(const EDot &);
  EDot &operator=(const EDot &);
  EDot(Exp *p1, Exp *p2);
  ~EDot();
  virtual void accept(Visitor *v);
  virtual EDot *clone() const;
  void swap(EDot &);
};

class EArrow : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EArrow(const EArrow &);
  EArrow &operator=(const EArrow &);
  EArrow(Exp *p1, Exp *p2);
  ~EArrow();
  virtual void accept(Visitor *v);
  virtual EArrow *clone() const;
  void swap(EArrow &);
};

class EDRef : public Exp
{
public:
  Exp *exp_;

  EDRef(const EDRef &);
  EDRef &operator=(const EDRef &);
  EDRef(Exp *p1);
  ~EDRef();
  virtual void accept(Visitor *v);
  virtual EDRef *clone() const;
  void swap(EDRef &);
};

class EIncr : public Exp
{
public:
  Exp *exp_;

  EIncr(const EIncr &);
  EIncr &operator=(const EIncr &);
  EIncr(Exp *p1);
  ~EIncr();
  virtual void accept(Visitor *v);
  virtual EIncr *clone() const;
  void swap(EIncr &);
};

class EDecr : public Exp
{
public:
  Exp *exp_;

  EDecr(const EDecr &);
  EDecr &operator=(const EDecr &);
  EDecr(Exp *p1);
  ~EDecr();
  virtual void accept(Visitor *v);
  virtual EDecr *clone() const;
  void swap(EDecr &);
};

class ENeg : public Exp
{
public:
  Exp *exp_;

  ENeg(const ENeg &);
  ENeg &operator=(const ENeg &);
  ENeg(Exp *p1);
  ~ENeg();
  virtual void accept(Visitor *v);
  virtual ENeg *clone() const;
  void swap(ENeg &);
};

class EMod : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EMod(const EMod &);
  EMod &operator=(const EMod &);
  EMod(Exp *p1, Exp *p2);
  ~EMod();
  virtual void accept(Visitor *v);
  virtual EMod *clone() const;
  void swap(EMod &);
};

class ETimes : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ETimes(const ETimes &);
  ETimes &operator=(const ETimes &);
  ETimes(Exp *p1, Exp *p2);
  ~ETimes();
  virtual void accept(Visitor *v);
  virtual ETimes *clone() const;
  void swap(ETimes &);
};

class EDiv : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EDiv(const EDiv &);
  EDiv &operator=(const EDiv &);
  EDiv(Exp *p1, Exp *p2);
  ~EDiv();
  virtual void accept(Visitor *v);
  virtual EDiv *clone() const;
  void swap(EDiv &);
};

class EPlus : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EPlus(const EPlus &);
  EPlus &operator=(const EPlus &);
  EPlus(Exp *p1, Exp *p2);
  ~EPlus();
  virtual void accept(Visitor *v);
  virtual EPlus *clone() const;
  void swap(EPlus &);
};

class EMinus : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EMinus(const EMinus &);
  EMinus &operator=(const EMinus &);
  EMinus(Exp *p1, Exp *p2);
  ~EMinus();
  virtual void accept(Visitor *v);
  virtual EMinus *clone() const;
  void swap(EMinus &);
};

class ESl : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ESl(const ESl &);
  ESl &operator=(const ESl &);
  ESl(Exp *p1, Exp *p2);
  ~ESl();
  virtual void accept(Visitor *v);
  virtual ESl *clone() const;
  void swap(ESl &);
};

class ESr : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ESr(const ESr &);
  ESr &operator=(const ESr &);
  ESr(Exp *p1, Exp *p2);
  ~ESr();
  virtual void accept(Visitor *v);
  virtual ESr *clone() const;
  void swap(ESr &);
};

class ELt : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ELt(const ELt &);
  ELt &operator=(const ELt &);
  ELt(Exp *p1, Exp *p2);
  ~ELt();
  virtual void accept(Visitor *v);
  virtual ELt *clone() const;
  void swap(ELt &);
};

class EGt : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EGt(const EGt &);
  EGt &operator=(const EGt &);
  EGt(Exp *p1, Exp *p2);
  ~EGt();
  virtual void accept(Visitor *v);
  virtual EGt *clone() const;
  void swap(EGt &);
};

class ENewLin : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ENewLin(const ENewLin &);
  ENewLin &operator=(const ENewLin &);
  ENewLin(Exp *p1, Exp *p2);
  ~ENewLin();
  virtual void accept(Visitor *v);
  virtual ENewLin *clone() const;
  void swap(ENewLin &);
};

class EEqual : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EEqual(const EEqual &);
  EEqual &operator=(const EEqual &);
  EEqual(Exp *p1, Exp *p2);
  ~EEqual();
  virtual void accept(Visitor *v);
  virtual EEqual *clone() const;
  void swap(EEqual &);
};

class ELtEq : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ELtEq(const ELtEq &);
  ELtEq &operator=(const ELtEq &);
  ELtEq(Exp *p1, Exp *p2);
  ~ELtEq();
  virtual void accept(Visitor *v);
  virtual ELtEq *clone() const;
  void swap(ELtEq &);
};

class EGtEq : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EGtEq(const EGtEq &);
  EGtEq &operator=(const EGtEq &);
  EGtEq(Exp *p1, Exp *p2);
  ~EGtEq();
  virtual void accept(Visitor *v);
  virtual EGtEq *clone() const;
  void swap(EGtEq &);
};

class EEq : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EEq(const EEq &);
  EEq &operator=(const EEq &);
  EEq(Exp *p1, Exp *p2);
  ~EEq();
  virtual void accept(Visitor *v);
  virtual EEq *clone() const;
  void swap(EEq &);
};

class ENEq : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ENEq(const ENEq &);
  ENEq &operator=(const ENEq &);
  ENEq(Exp *p1, Exp *p2);
  ~ENEq();
  virtual void accept(Visitor *v);
  virtual ENEq *clone() const;
  void swap(ENEq &);
};

class EAnd : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EAnd(const EAnd &);
  EAnd &operator=(const EAnd &);
  EAnd(Exp *p1, Exp *p2);
  ~EAnd();
  virtual void accept(Visitor *v);
  virtual EAnd *clone() const;
  void swap(EAnd &);
};

class EOr : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EOr(const EOr &);
  EOr &operator=(const EOr &);
  EOr(Exp *p1, Exp *p2);
  ~EOr();
  virtual void accept(Visitor *v);
  virtual EOr *clone() const;
  void swap(EOr &);
};

class ECond : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ECond(const ECond &);
  ECond &operator=(const ECond &);
  ECond(Exp *p1, Exp *p2);
  ~ECond();
  virtual void accept(Visitor *v);
  virtual ECond *clone() const;
  void swap(ECond &);
};

class ECond2 : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ECond2(const ECond2 &);
  ECond2 &operator=(const ECond2 &);
  ECond2(Exp *p1, Exp *p2);
  ~ECond2();
  virtual void accept(Visitor *v);
  virtual ECond2 *clone() const;
  void swap(ECond2 &);
};

class EThrow : public Exp
{
public:
  Exp *exp_;

  EThrow(const EThrow &);
  EThrow &operator=(const EThrow &);
  EThrow(Exp *p1);
  ~EThrow();
  virtual void accept(Visitor *v);
  virtual EThrow *clone() const;
  void swap(EThrow &);
};



class ListDef : public Visitable, public std::vector<Def*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListDef *clone() const;
};

class ListArg : public Visitable, public std::vector<Arg*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListArg *clone() const;
};

class ListStm : public Visitable, public std::vector<Stm*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListStm *clone() const;
};

class ListType : public Visitable, public std::vector<Type*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListType *clone() const;
};

class ListExp : public Visitable, public std::vector<Exp*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListExp *clone() const;
};

class ListId : public Visitable, public std::vector<Id>
{
public:
  virtual void accept(Visitor *v);
  virtual ListId *clone() const;
};



#endif
